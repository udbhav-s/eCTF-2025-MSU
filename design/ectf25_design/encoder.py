"""
Author: MSU Spartans
Date: 2025

Satellite TV Frame Encoder
With Encryption and Signing
"""

import argparse
import struct
import json
from Crypto.Cipher import ChaCha20
from Crypto.Random import get_random_bytes
from ectf25_design import Secrets, ChannelKeyDerivation
from Crypto.PublicKey import ECC
from Crypto.Signature import eddsa

class Encoder:
    def __init__(self, secrets: bytes):
        """
        You **may not** change the arguments or returns of this function!

        :param secrets: Contents of the secrets file generated by
            ectf25_design.gen_secrets
        """
        # Load the json of the secrets file
        secrets: Secrets = json.loads(secrets)

        # Process secrets
        for k, val in secrets["channels"].items():
            secrets["channels"][k] = bytes.fromhex(val)

        # Save secrets
        self.secrets = secrets

        # Load the host key and create signer
        host_key = ECC.import_key(bytes.fromhex(secrets["host_key_priv"]))
        self.signer = eddsa.new(host_key, 'rfc8032')

    def encode(self, channel: int, frame: bytes, timestamp: int) -> bytes:
        """The frame encoder function

        This will be called for every frame that needs to be encoded before being
        transmitted by the satellite to all listening TVs

        You **may not** change the arguments or returns of this function!

        :param channel: 32b unsigned channel number. Channel 0 is the emergency
            broadcast that must be decodable by all channels.
        :param frame: Frame to encode. Max frame size is 64 bytes.
        :param timestamp: 64b timestamp to use for encoding. **NOTE**: This value may
            have no relation to the current timestamp, so you should not compare it
            against the current time. The timestamp is guaranteed to strictly
            monotonically increase (always go up) with subsequent calls to encode

        :returns: The encoded frame, which will be sent to the Decoder
        """
        assert str(channel) in self.secrets["channels"].keys()
        channel_root = self.secrets["channels"][str(channel)]

        deriv = ChannelKeyDerivation(root=channel_root, height=64)

        frame_key = deriv.extend_key(deriv.get_frame_key(timestamp))

        nonce = get_random_bytes(12)
        cipher = ChaCha20.new(key=frame_key, nonce=nonce)
        encrypted_frame_data = cipher.encrypt(frame)

        header_bytes = struct.pack("<IQ12s", channel, timestamp, nonce)

        frame_content = header_bytes + encrypted_frame_data
        signature = self.signer.sign(frame_content)

        final_frame = frame_content + signature

        return final_frame
