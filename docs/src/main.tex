\documentclass[12pt]{article}

% Packages
\usepackage[margin=1in]{geometry}  % Page margins
\usepackage{titlesec}              % For formatting section titles
\usepackage{enumitem}              % For better list formatting


% Title formatting
\titleformat{\section}
  {\large\bfseries}  % Format of the section title
  {}                 % Label
  {0pt}              % Separation between label and title
  {}                 % Before-code

% Define heading formats
\titlespacing*{\section}{0pt}{24pt}{12pt}
\titlespacing*{\subsection}{0pt}{12pt}{6pt}

% Document begins
\begin{document}

% Title
{\centering
\Huge\textbf{MITRE eCTF 2025}

\vspace{1cm}
\Large\textbf{Initial Design Document: Team Spartans}

\vspace{0.5cm}
\Large [Michigan State University]

\vspace{2cm}
}

\section*{Overview of our System}

Our system will involve a series of \textbf{control keys} K1, K2, \ldots, Kn (one for each decoder n) for the entire system and a series of \textbf{channel keys} for each channel. The control key will be preloaded into the firmware of the decoder and only accessible upon selective calls from secure functions. 

Upon successful negotiation between the TV service and client for channel access, the client will be able to upload a signed \textbf{subscription package} to their decoder. The package contains a key to be used in decrypting a specific channel's frames, and is encrypted using the control key specific to that decoder. 

The package is also signed for authenticity using a \textbf{manufacturer keypair}, where the \textbf{manufacturer secret key} is held by the encoder, and all decoders receive the \textbf{manufacturer public key} by which they can verify the signature of the package. The channel key is only usable by the decoder once decrypted by the pre-shared control key. If the client purchases X number of channels at the same time, they will receive X encrypted and signed channel keys.

\newpage
% Build Process section
\section*{Build Process}

\subsection*{Build Environment}
While building the environment for a single deployment, the following keys will be generated and stored in the Global Secrets:
\begin{itemize}
  \item Manufacturer Keypair
  \item Control Keys (one per decoder)
  \item Channel Keys for Channels 1-4
\end{itemize}

\subsection*{Build Decoder}
When building the decoder, it is provided with:
\begin{itemize}
  \item Control key (specific to this decoder)
  \item Manufacturer Public Key
  \item Channel Key for Channel 0
\end{itemize}

\vspace{1cm}

\section*{Key Management}
Our system uses an asymmetric signing keypair, a unique secret corresponding to each decoder, and a unique secret for every (channel, timestamp) combination: the unique frame key.\\
Because the cardinality of the set is $1 + 2^{32} + 2^{32}\times2^{64} \approx 2^{96}$, we cannot pre-generate and store this many keys during secret generation time; instead, we designed a key derivation strategy.\\
At secret generation time, the list of channels which are to be supported are already given. Therefore, we generate a secret key corresponding to each channel at this time and store a mapping from channel id to channel secret.\\
Unlike the channel list, the set of decoder IDs to be supported is not known at secret generation time. Therefore, we generate a single root decoder key at secret generation time, and use this root key along with the decoder's unique id to derive a unique decoder key at decoder build time.\\
For integrity verification, an asymmetric signing keypair is generated at secret generation time, and the public key is distributed to each decoder, while the private key is held by the encoder alone.\\
\subsection*{Frame Key Derivation Tree}
The frame key was the most challenging to implement; we need to have a unique frame key for every possible (channel, timestamp) combination, and each decoder authorized to listen to a given channel must receive all the frame keys for that channel from the start timestamp to the ending timestamp through its subscription package.\\
In order to accomplish this, we create a tree structure for key derivation. The channel secret described above serves as the root of the tree, and there are $2^64$ leaf nodes which are the frame keys of that channel for each timestamp. This tree is again too large to store, but any node can be derived random-access from any ancestor node. Each child node in this binary tree is the hash of the parent node plus a direction, left or right. This means that no parent may be derived from a child (for a preimage-resistant hash), but the descendants may all be derived from the ancestor. Note that this is not a Merkle tree, where the parent is derived from the children, but the opposite, where the children are derived from the parent.\\
In our subscription package, we convey the appropriate covering of the binary tree from the leftmost leaf node to the rightmost leaf node requried by the start and end timestamps. This covering contains no parent of a disallowed node, but otherwise contains as few nodes as possible by giving nodes as high in the tree as possible. The height of this tree is $64$, and typical coverings do not exceed $80$ nodes.\\
The following diagram illustrates the tree structure:
\includegraphics[width=0.5\textwidth]{tree.png}

\section*{Algorithms}
We use the following algorithms in our system:
\begin{itemize}
  \item ED25519 for asymmetric signature and verification
  \item HKDF-SHA512 for decoder key derivation
  \item MD5 Reverse Hash Tree for frame key derivation
  \item ChaCha20 for encryption and decryption

% Security Requirements section
\section*{Security Requirements}

\subsection*{Security Requirement 1}
\textbf{An attacker should not be able to decode TV frames without a Decoder that has a valid, active subscription to that channel.}

All frames sent by the system will be encrypted with the corresponding frame key. This frame key cannot be derived without posession of one of its ancestor node keys, which only validly subscribed decoders will posess through their subscription package. This subscription package will itself be encrypted with the unique decoder key shared by the host and the rightful recipient of the subscription package. As such, a third party should not have access to the frame key and will not be able to decode frames for the channels that are encrypted by the Encoder.

\subsection*{Security Requirement 2}
\textbf{The Decoder should only decode valid TV frames generated by the Satellite System the Decoder was provisioned for.}

A third party without the \textit{channel key} should not be able to create frames that are encrypted with this key, assuming the secrets in decoder firmware and the encoder infrastructure are inaccessible to the attacker. Since the subscription packages will be encrypted with the pre-shared key, they cannot be read by parties other than the Encoder and Decoder. The frames may also be additionally signed using a Manufacturer Secret Key to verify the authenticity, if the process fits within the time constraints for decoding a frame.

\subsection*{Security Requirement 3}
\textbf{The Decoder should only decode frames with strictly monotonically increasing timestamps.}

The firmware will keep track of the last frame received for each channel in volatile memory. If a received frame has a timestamp lower than this value, the decoder will reject decoding the frame.

\newpage
% Functional Requirements section
\section*{Encoder Functional Requirements}

\subsection*{Encode Frames}
The encoder will encode each channel's frames with a \textit{channel key}, then it will associate the channel number and timestamp with the frame. Each frame may also be signed by the Manufacturer Secret Key. Each frame will then be sent to the uplink to be transmitted to the satellite.

\section*{Decoder Functional Requirements}

\subsection*{Decoder Functional Requirement 1}
\textbf{List Channels}

The decoder will maintain a list of channels it has a valid subscription for. Upon receiving an authentic subscription update package, the decoder will update the list. Once a subscription has ended, the access to the channel will be removed from the list.

\subsection*{Decoder Functional Requirement 2}
\textbf{Update Subscriptions}

Upon receiving a subscription update, the decoder will update the specified channel or set of channels as a part of the update package. After decrypting the \textit{channel keys} associated with a specific channel, it will store them and then update the channels list.

\subsection*{Decoder Functional Requirement 3}
\textbf{Decode Frame}

When attempting to view a channel, the decoder will check against the channel list to ensure it has access to the channel. If it has access, then it will use the \textit{channel key} to decrypt each frame and will check against the associated time stamp in the frame with the access period of the channel subscription. If all of the attributes are valid then the frame will be viewable, otherwise the frames will remain encoded.

\section*{Security Enhancement}
The use of a series of keys K1, K2, \ldots, Kn specific to each decoder n keeps the system secure in the Pirated Subscription scenario. Each subscription package will be signed by a key specific to the decoder the channel is being provisioned for, to prevent other decoders in the same deployment from decrypting it. The encryption of channel frames remains the same, using the channel key.

\end{document}
